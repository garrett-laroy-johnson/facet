<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>nnirror</title>
    <script src="node_modules/codemirror/lib/codemirror.js"></script>
    <link rel="stylesheet" href="node_modules/codemirror/lib/codemirror.css">
    <link rel="stylesheet" href="node_modules/codemirror/theme/mbo.css">
    <link rel="stylesheet" type="text/css" href="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css">
    <script src="node_modules/codemirror/mode/javascript/javascript.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="facet.js"></script>
    <script src="node_modules/bootstrap-growl/bootstrap-notify.min.js"></script>
    <script type="text/javascript" src="node_modules/osc-js/lib/osc.min.js"></script>
    <style media="screen">
      html {
        height: 1000px;
      }
      .CodeMirror {
        height: 98vh;
        font-size: 2em;
      }
    </style>
  </head>
  <body>
    <script type="text/javascript">
    var cm = CodeMirror(document.body, {
      // could somehow "load" scripts with this value function, or use a button UI to pull in old files
      value: `every(1) k1 struct [sine(random(200,5,1),random(4,8,1))]
  .am(sine(random(1,10,0),100)).prob(random(0.125,0.25,0));
s1 struct [sine(random(2,10,1),random(1,4,1))].am(sine(random(1,20,0),100))
  .fracture(4).map([0,0.5,1]).prob(0.1).sticky(0.75);
h1 struct [sine(random(2,100,1),random(1,4,1))].am(sine(random(1,30,0),100))
  .fracture(4).map([0,0.5,1]).prob(random(0.1,0.6,0)).sticky(0.5);
a1 struct [sine(random(40,80,1),random(1,4,1))].am(sine(random(1,40,0),100))
  .fracture(4).map([0,0.5,1]).prob(0.125);
comb send [sine(100,4)].am(tri(10,50)).scale(0,0.5);
comb feed [drunk(64, 0.5)];
comb time [sine(1,100)].scale(0,1).gain(random(0,10,0)).sticky(0.8)
  .fracture(random(1,8,1));
verb send [sine(12,60)].am(sine(random(10,20,0),100)).scale(0,0.2);
verb time [ramp(0,1,256)].am(sine(6,60)).scale(0.33,1).sticky(0.7);
verb warp [ramp(50,2000,256)].am(sine(6,60));
verb feed [drunk(128, 0.3)].scale(0,1);
filter cutoff [sine(random(1,12,1),100)].scale(0,1).gain(3000).pong(1000,1500);
global bpm [24].dup(1).append(32).append(40).append(48);
k1 samp [tri(4,16)];
s1 samp [drunk(64,0.25)];
a1 samp [drunk(32,2)].scale(0.2,1);
h1 samp [drunk(128,0.25)];

clearevery();

mute();`,
        mode:  "javascript",
        theme: "mbo",
        lineWrapping: true
      });
      function getFirstLineOfBlock(initial_line) {
        // true if line above is empty or the line number gets to 0
        let above_line_is_empty = false;
        let current_line_number = initial_line;
        let first_line;
        while ( above_line_is_empty == false && current_line_number >= 0 ) {
          // check previous line for conditions that would indicate first line
          // of block; otherwise continue decrementing line number
          if ( (current_line_number ) == 0 ) {
            first_line = 0;
            break;
          }
          let line_above = cm.getLine(current_line_number - 1);
          if ( line_above.trim() == '' ) {
            above_line_is_empty = true;
            first_line = current_line_number;
          }
          current_line_number--;
        }
        return first_line;
      }
      function getLastLineOfBlock(initial_line) {
        // true if line below is empty or the line number gets to cm.lineCount()
        let below_line_is_empty = false;
        let current_line_number = initial_line;
        let last_line;
        while ( below_line_is_empty == false ) {
          if ( (current_line_number + 1) == cm.lineCount() ) {
            last_line = current_line_number;
            break;
          }
          // check below line for conditions that would indicate last line
          // of block; otherwise continue incrementing line number
          let line_below = cm.getLine(current_line_number + 1);
          if ( line_below.trim() == '' ) {
            below_line_is_empty = true;
            last_line = current_line_number;
          }
          current_line_number++;
        }
        return last_line;
      }

      function isGlobalCommand(code) {
        if ( code == 'mute();' ) {
          return true;
        }
        return false;
      }

      $(document).keydown(function(e) {
        // [ctrl + enter] to select text and send to Max server (127.0.0.1:1123)
        if ( e.ctrlKey && e.keyCode == 13 ) {
          parseCode();
        }
      });

      function parseCode() {
        // select the entire block surrounding the cursor pos, based on if
        // newlines exist above and below
        let cursor = cm.getCursor();
        let line = cursor.line;
        let first_line_of_block = getFirstLineOfBlock(line);
        let last_line_of_block = getLastLineOfBlock(line);
        // highlight the text that will run for 100ms
        cm.setSelection({line: first_line_of_block, ch: 0 }, {line: last_line_of_block, ch: 10000 });
        // de-highlight, set back to initial cursor position
        setTimeout(function(){ cm.setCursor({line: line, ch: cursor.ch }); }, 100);
        let code = cm.getSelection();
        runFacet(code);
      }

      function runFacet(code) {
        let facet_data = {};
        if ( !isGlobalCommand(code) && !isEveryNStatement(code) ) {
          // for global commands like mute(), simply run those functions which reinitialize all data to 0
          facet_data = facetParse(code);
        }
        else {
          commands = getCommands(code);
          Object.values(commands).forEach(command => {
            if ( isEveryNStatement(command) ) {
              if ( isClearEveryNStatement(command) ) {
                undoEveryNStatement(command);
              }
              else {
                every_n_hooks = {};
                parseEveryNStatement(command);
              }
            }
            else {
              // global commands are eval'd as-is. so e.g. the command "mute();"
              // would run the mute() function which will send a value of global[mute]: 0
              // to every facet_param in Max, basically unsetting all buffers.
              facet_data = eval(command);
            }
          });
        }

        $.post('http://127.0.0.1:1123', facet_data);
        // re-initialize the facets object after it has been parsed
        facets = facetInit();
      }

      function mute() {
        // mute clears the every_n_hooks object too
        undoEveryNStatement('clearevery()');
        return {global: { mute: 0 }};
      }

      // begin EVERY
      function isEveryNStatement(code) {
        return /every\([a-zA-Z0-9, .()]*\)/gm.test(code);
      }

      function isClearEveryNStatement(code) {
        return /clearevery\([0-9]*\)/gm.test(code);
      }

      function undoEveryNStatement(code) {
        let every_n_matches = code.match(/clearevery\([0-9]*\)/gm);
        let every_n_split = code.split(/clearevery\([0-9]*\)/gm);
        if ( every_n_matches ) {
          for (const [key, every] of Object.entries(every_n_matches)) {
            let n = Number(every.replace('(', '').replace(')', '').replace('clearevery', ''));
            // if no args, clears all hooks
            if ( n == 0 ) {
              every_n_hooks = {};
            }
            // if the command is for clearevery(5), this will delete the hook that runs every 5
            delete every_n_hooks[Number(n)];
          }
        }
      }

      function parseEveryNStatement(code) {
        let every_n_matches = code.match(/every\([a-zA-Z0-9, .()]*\)/gm);
        let every_n_split = code.split(/every\([a-zA-Z0-9, .()]*\)/gm);
        let prob = 1;
        if ( every_n_matches ) {
          for (const [key, every] of Object.entries(every_n_matches)) {
            let n = Number(every.replace('(', '').replace(')', '').replace('every', ''));
            if ( isNaN(n) ) {
              try {
                n = every.replace('every(', '').replace(' ', '').slice(0, -1);
                let n_split = n.split(',');
                // get probability coefficient
                prob = Number(n_split[1]);
                n = eval(n_split[0]);
              } catch (e) {
                $.notify(`Could not parse every(n) statement.`, {
                  allow_dismiss: true,
                  delay: 500,
                  newest_on_top: true
                });
              }
            }
            // if the command is for every(5), this will take whatever code ran after the every(5),
            // UNTIL the next every N (if it exists), and set that in the every_n_hooks obj
            if ( !every_n_hooks[n] ) {
              every_n_hooks[n] = [];
            }
            every_n_hooks[n].push({
              code: every_n_split[Number(key)+1],
              prob: prob
            });
          }
        }
      }

      function getHooksToRunEveryN() {
        let hooks_to_run = '';
        if  ( every_n_hooks ) {
          for (const [key, everys] of Object.entries(every_n_hooks)) {
            if ( num_cycles % key == 0 ) {
              for (var i = 0; i < everys.length; i++) {
                // it's time to rerun the code at this hook for every n bars
                let code = everys[i];
                if ( Math.random() < code.prob ) {
                  hooks_to_run += code.code.trim();
                }
              }
            }
          }
          return hooks_to_run;
        }
        else {
          return false;
        }
      }
      // end EVERY

      // begin OSC
      let num_cycles = 0;
      let every_n_hooks = {};
      const osc = new OSC({ plugin: new OSC.WebsocketClientPlugin() });

      connectToMaxOscServer();

      osc.on('/eoc', message => {
        if ( message.args[0] == 'bang' ) {
          num_cycles++;
          hooks_code = getHooksToRunEveryN();
          if ( hooks_code ) {
            runFacet(hooks_code);
          }
        }
      });

      function connectToMaxOscServer() {
        let interval = setInterval( () => {
          osc.open();
          setTimeout( () => {
            if ( osc.status() == 1 ) {
              // connected!
              clearInterval(interval);
              $.notify(`Connected to OSC server.`, {
                allow_dismiss: true,
                delay: 500,
                newest_on_top: true
              });
            }
            else {
              $.notify(`Could not connect to OSC server in Max.`, {
                allow_dismiss: true,
                delay: 500,
                newest_on_top: true
              });
            }
          }, 1000);
        }, 3000);
      }
      // end OSC
    </script>
  </body>
</html>
